![[Java 鎖.webp]]

## 1. 樂觀鎖 悲觀鎖

- 樂觀鎖：假定讀取的時候資源不會被修改，寫回之後校驗是否寫成功。如果不成功，或報錯，或自動重試。樂觀鎖在 Java 中使用 CAS 類，通常採用 CAS 算法。**適合多讀**
- 悲觀鎖：讀時加鎖，確保數據不會被更改。  **適合多寫**


## 2. 自旋鎖 適應性自旋鎖


- 自旋鎖：如果獲取資源失敗，則忙等
- 適應性自旋鎖：忙等一定的次數後，阻塞此線程

因爲如果同步代碼很簡單，可能大部分時間都在等待和喚醒的線程切換上，因此失敗後忙等。但忙等會消耗 CPU，故等待時間不能過長。

**自旋鎖的實現就是 CAS**

## 3. 無鎖 偏向鎖 輕量級鎖 重量級鎖

总结而言： 偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。

## 4. 公平鎖 非公平鎖

- 公平鎖：按照請求順序排隊
- 非公平鎖：可以插隊，減少線程切換的開銷

## 5. 可重入鎖 非可重入鎖

```java
public class Widget { 
	public synchronized void doSomething() { 
		System.out.println("方法1执行..."); 
		doOthers(); 
	} 
	public synchronized void doOthers() { 
		System.out.println("方法2执行..."); 
	} 
}

```

- 可重入鎖：調用 `doSomething` 時，會成功執行 `doOthers` 
- 不可重入鎖：發生死鎖

實現：

- 拿到鎖後判斷 $status$ 是否爲 `0` , 
- 如果不爲 0，判斷當前的線程是否拿到了鎖，如果是，則 $status + 1$，並進入。否則等待
- 不可重入鎖會直接判斷 $status$ 是否是0，不是直接等待

## 6. 共享鎖 排他鎖

實現：讀寫鎖

讀鎖共享，寫鎖排他