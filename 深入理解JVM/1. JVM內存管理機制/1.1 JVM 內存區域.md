![[1.1 內存區域.png]]

## 1. JVM 運行時數據區域

1. 程序計數器
	- 程序計數器記錄了當前 JVM 執行到字節碼的哪一行。
	- 在執行 native 方法時未定義
	- **惟一不會拋出 OOM 的區域**
2. 虛擬機棧
	- Java 方法棧，保存每個 JVM 方法執行的數據，包括棧
	- 會出現 OOM 和 StackOverflowError
	- 出現OOM說明虛擬機棧動態擴展時無法申請到足夠的內存，解決方法是**調小 JVM 堆大小**，因爲調小 Heap 大小 JVM 可以給棧幀更多的內存。
	- JVM 參數： `-Xss`
3. 本地方法棧
	- native 方法執行的棧
	- 會拋出 `OutOfMemoryError` 和 `StackOverflowError`
4. Heap 區
	- 存放 Java 對象，
	- GC 主要管理的區域
	- 當分配對象時，Heap 中沒有足夠的內存且無法再***擴展***時，會拋出 OOM
	- 可以處於不連續的物理內存區域
	- JVM 參數，***可以設定 `-Xmx` 和 `-Xms` 相同來防止 JVM Heap 自動擴展。***
		- `-Xmx`: Heap 最大值
		- `-Xms`: Heap 最小值
5. 方法區
	- 存放 Java 常量、靜態變量、*~~字符串池~~*（在 Java Heap 中）、Class 對象和 JIT 編譯後的代碼。f
	- 運行時常量池：包括字面量
	- GC 也會回收，但是很少
	- 使用 Spring 這樣的反射和動態生成類的框架時，要特別注意方法區的回收
	- 會拋出 `OOM`
6. 直接內存
	- 使用 NIO API分配
	- 手動分配，手動釋放
	- 基於通道和緩衝區的I/O方式，在Java堆中存儲一個 `DirectByteBuffer` 作爲堆外對象的引用，直接操作堆外內存，避免複製。
	- 虛擬機參數：`-XX:MaxDirectMemorySize`，***默認等於`-Xmx`的大小***
	- ***會出現OOM***，因爲默認直接內存和 Heap 大小一樣

## 2. HotSpot 堆中的對象

### 對象的創建過程

1. 檢查能否在常量池中找到一個類的符號引用，並且這引用代表的類的是否已經被加載、解析和初始化過，如果沒有，則加載這個類。
2. 加載類後，確定對象需要的內存大小，並爲這個對象分配堆內存
3. 將分配的內存初始化
4. 設置對象頭，此時虛擬機認爲對象已經初始化完成
5. 調用對象的構造方法

#### 在堆中爲新對象劃分內存

- **指針碰撞（分配規整）**， 用一個指針劃分爲兩個區域，一個用過，一個沒用
- **空閒列表（分配不規整）**，列表記錄空閒的內存，分配時找到一個足夠分配的位置，更新列表

#### 多線程創建對象，分配內存同步問題

- 對分配內存的動作進行同步處理（CAS），我理解的就是加鎖等常見的同步方法
- 每個線程事先分配一塊單獨的堆內存，稱爲本地線程分配器緩衝（Thread Local Allocation Buffer, TLAB），每個線程只在自己的 TLAB 上分配，只有當 TLAB 用完時，纔需要同步鎖定（用完就使用前一種方法分配）
- JVM 參數： `-XX:+/-UseTLAB` 是否使用 TLAB

### 對象的內存佈局

1. 對象頭
	- 運行時數據，包括 HashCode、 GC 分代年齡等
	- 類型指針，指向類元數據的指針，HotSpot使用的是直接指針。
	- 數據長度（非數組不需要）
2. 實例數據
	- 默認分配順序：long/double、int、short/char、byte/boolean、oop(Ordinary Object Pointer)，除了oop以外，從長到短
	- 默認父類字段在子類字段之前
*HotSpot 要求 8 字節對齊*

### 對象訪問

#### 句柄訪問

在 Java 堆中分配一塊句柄池存放對象實例和類型數據的指針

#### 直接訪問

Java 堆中存放實例數據，其類型指針指向方法區的類型
